#!/usr/bin/env perl6

=begin pod
=head1 QSim -- Monte Carlo Simulation of Queue Networks

This program allows simulating networks of queues and processors, like the
ones analyzed and describe by Agner Krarup Erlang and David George Kendall. It 
does this not via proper maths, but simply by mote carlo simulation. This is 
less elegant, but easier for me and allows analyzing complicated cases as well.

The model used by this simulation is not as minimal and pure as it could be. 
This is done in the hope that it makes the expression of networks to be 
analyzed more concise. For example, this supports a "failure" mode that directly
routes to a specific point and skips further processing.

XXX more general docs

=head2 Data Model

The network being analyzed needs to be expressed as a graph of related objects 
from a relatively small set of types. It is important to understand these types
and what properties they have:

=head3 Queues

At the very heart of this model are queues of course, these can exhibit 
different behavior specified by a queue size, which can be infinite, and the 
behavior on overflow. For the latter this code supports three modes: cause 
failures on overflow (see below for failures), block the processor that is 
trying to put items on the queue, or just drop messages.

All queues in this model are FIFO.
=end pod

enum QueueOverflowBehavior (
    FAIL => 1,
    BLOCK => 2,
    DROP => 3,
);

class Queue {
    has $.size;
    has $.overflow-behavior;
    has $.sink is rw;
    
    method plot-node($id) {
        say "  $id [label=\"Queue s=$!size\", shape=rect]";
    }
}

=begin pod
=head3 Processors

At the end of each queue sits a processor that consumes messages from the queue, 
does something with them by virtue of a processing callable that modifies the
item if necessary and also determines the simulated time needed for this 
processing.

Processors also have a configurable capacity of how many items can be processed
in parallel.
=end pod

class Processor {
    has $.capacity;
    has $.proc-func;
    has $.sink is rw;
    
    method plot-node($id) {
        say "  $id [label=\"Processor c=$!capacity\", shape=ellipse]";
    }
}

=begin pod
=head3 Routes

Processors emit their messages to routes which are typically (but see next 
paragraph for exceptions) connected to one or more sink queues, and have a 
function that decides which queue a message should be routed to.

There are exactly two exceptional routes in any model this software uses: 
an input route that receives all messages that are sent through the network.
These are not emitted by a processor but by a network simulation test bed 
object. Similarily, there is a single route that does not emit messages into 
a queue, the output route that sends (non-failure) messages to the test bed
receiver.

Messages are delivered instantaneous trough routes, if you want to simulate
different, i.e. real-world behaviour, you need to model things like a network
transmission as a queue and a simple processor.

So a simple setup could look like this:

=begin code
                                            Processor
                      Queue                  ,----.
              -+---------------------+      /      \
      +------> | | | | s=5 | | | | | |----->| c=2  |-----+
      |       -+---------------------+      \     /      |
      |                                      `---'       |
      |                                                  V
    +--------------------------------------------------------+
    |                                                        |
    |                 SIMULATION TEST BED                    |
    |                                                        |
    +--------------------------------------------------------+
=end code
=end pod

class Route {
    has @.sinks is rw;
    has $.sink-select-func;
}

=begin pod
=head3 Simulation Test Bed

The simulation test bed produces messages using a producer callable that also
defines the interval between a message and the next, and then sends these 
messages through the network. They either arrive back at the test bed through
regular routing, or through a specal failure channel.
=end pod

class TestBed {
    has $.sink is rw;
    has $.producer-func;

    method plot-node($id) {
        say "  $id [label=\"TestBed\", shape=parallelogram, rank=0]";
    }
}

# XXX docs, also needs to have slurpy second arg
sub connect($a, $b) {
    $a.sink = Route.new(sinks => ($b));
}

my $example = TestBed.new;
my $q1 = Queue.new(size => 5);
my $p1 = Processor.new(capacity => 2);

connect($example, $q1);
connect($q1, $p1);
connect($p1, $example);

sub plot-network($start-node) {
    my $node = $start-node;
    my %seen{Any}; # XXX put outside inner loop
    my $node-id-seq = 1;

    # XXX put testbed in own subgraph to render it outside the 
    # rest of the graph

    say "digraph G \{";
    say "  rankdir=LR";

    sub rec-iterate($node) {
        if %seen{$node} {
            return %seen{$node};
        }

        %seen{$node} = $node-id-seq;
        $node.plot-node($node-id-seq); 
        my $node-id = $node-id-seq++;
        my $route = $node.sink;
        for $route.sinks -> $next-node {
            my $next-id = rec-iterate($next-node);
            say "  $node-id -> $next-id"
        }
        return $node-id;
    }

    rec-iterate($start-node);

    say "\}";
}

plot-network($example);

# XXX need an event scheduler

sub simulate($samples) {
    # XXX loop over $samples and emit them, essentially just placing them in the
    # scheduler. this needs all nodes to be connected to a scheduler, perhaps we
    # just pass that into the handle call? 
    # once we have them all emitted, just work on the scheduler until it is
    # drained
}

# XXX how do we get a poisson-distributed random distance function
# https://preshing.com/20111007/how-to-generate-random-timings-for-a-poisson-process/
# generate random number 0..1 if we want an event every X on average, then we
# need -ln U * X as the interval to the next. try this

sub random-poisson-distance($average-distance) {
    return 1.rand.log * $average-distance * -1;
}

# based on this we can build a simple event generator for the testbed
sub tb-producer() {
    return (random-poisson-distance(60), "");
}

# so the simulator can just loop over the number fo samples with a time
# initialized to zero, and increment the time with what was returned

# my $total = 0.0;
# my @hist;
# for ^1000000 {
#     my $sample = random-poisson-distance(4);
#     $total += $sample;
#     my $idx = round($sample*20);
#     @hist[$idx]++;
#     
# }
# say "total: $total";
# my $idx = 0;
# for ^500 -> $idx {
#     my $cv = @hist[$idx] // 0;
#     say "$idx $cv";
# }
